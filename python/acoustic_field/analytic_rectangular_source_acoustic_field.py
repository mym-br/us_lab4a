# This file is in the public domain.

import numpy as np
import math

# Calculate the acoustic field generated by a flat rectangular surface,
# using the analytic solution provided by:
# Emeterio, J. L. S.
# Ullate, L. G.
# Diffraction impulse response of rectangular transducers.
# J. Acoust. Soc. Am., vol. 92, no. 2, pp. 651-662, 1992.
# DOI: 10.1121/1.403990
#
# Note:
# - The source is surrounded by a rigid baffle.
class AnalyticRectangularSourceAcousticField:
    def __init__(self, width, height, sample_rate, c, min_edge_divisor=None):
        """Construct an AnalyticRectangularSourceAcousticField.

        width: Width of the source (m).
        height: Height of the source (m).
        sample_rate (Hz).
        c: Propagation speed (m/s).
        min_edge_divisor:
            If it is not None, an exception will be raised if the sample rate
            is not high enough to make sigma grow less than
            min(width, height) / min_edge_divisor from t_min to t_min + T,
            where T is the sampling period.
        """
        # a must be <= b.
        if width <= height:
            self.a = width / 2
            self.b = height / 2
            self.swap_x_y = False
        else:
            self.b = width / 2
            self.a = height / 2
            self.swap_x_y = True
        self.sample_rate = sample_rate
        self.c = c
        if min_edge_divisor is not None:
            self.min_a_divisor = min_edge_divisor / 2
        else:
            self.min_a_divisor = None

    def get_impulse_response(self, x, y, z):
        """Get the impulse velocity potential at a point.

        x, y, z: Coordinates of the point (m).

        Return:
            offset: Absolute index of the first sample in h.
            h:      Impulse velocity potential.
        """

        # The field is symmetric.
        x = abs(x)
        y = abs(y)
        z = abs(z)

        if self.swap_x_y:
            x, y = y, x

        z2 = z**2
        c2 = self.c**2
        half_pi = np.pi / 2.0

        # Figure 2.
        d1 = x - self.a
        d2 = y - self.b
        d3 = x + self.a # d3 > 0
        d4 = y + self.b # d4 > 0

        # (7)
        ta = np.sqrt(d1**2 + d2**2 + z2) / self.c
        tb = np.sqrt(d2**2 + d3**2 + z2) / self.c
        tc = np.sqrt(d1**2 + d4**2 + z2) / self.c
        td = np.sqrt(d3**2 + d4**2 + z2) / self.c
        # (8)
        ts1 = np.sqrt(d1**2 + z2) / self.c
        ts2 = np.sqrt(d2**2 + z2) / self.c
        # (9)
        t0 = z / self.c

        # Determine the region and the start time of the impulse response.
        if x >= self.a:
            if y >= self.b:
                region = 1
                t_min = ta
            else:
                region = 3
                t_min = ts1
        else:
            if y >= self.b:
                region = 2
                t_min = ts2
            else:
                region = 4
                t_min = t0

        dt = 1.0 / self.sample_rate
        if self.min_a_divisor is not None:
            delta_a = self.a / self.min_a_divisor
            sigma1 = np.sqrt(max(c2 * t_min**2 - z2, 0.0))
            sigma2 = sigma1 + delta_a
            max_dt = np.sqrt(sigma2**2 + z2) / self.c - t_min
            if dt > max_dt:
                raise Exception("The sampling rate is too low (fs={} min_fs={}).".format(self.sample_rate, 1.0 / max_dt))

        # (13)
        tm1 = min(tb, tc)
        tm2 = max(tb, tc)

        min_absolute_index = math.ceil(t_min * self.sample_rate)
        max_absolute_index = math.ceil(td * self.sample_rate)
        h = np.zeros(max_absolute_index - min_absolute_index + 1)
        t_offset = min_absolute_index * dt

        sigma_eps = self.a * np.spacing(1)

        if region == 1:
            i1 = 0
            i2 = math.ceil(tm1 * self.sample_rate) - min_absolute_index
            i3 = math.ceil(tm2 * self.sample_rate) - min_absolute_index
            i4 = max_absolute_index - min_absolute_index

            i = np.arange(i1, i2)
            t = t_offset + i * dt
            sigma = np.sqrt(np.maximum(c2 * t**2 - z2, 0.0))
            inv_sigma = 1.0 / sigma
            alpha1 = np.arcsin(np.minimum(d1 * inv_sigma, 1.0))
            alpha2 = np.arcsin(np.minimum(d2 * inv_sigma, 1.0))
            h[i] = half_pi - alpha1 - alpha2
            h[i[sigma <= sigma_eps]] = 0.0
            if tb <= tc:
                i = np.arange(i2, i3)
                t = t_offset + i * dt
                inv_sigma = 1.0 / np.sqrt(c2 * t**2 - z2)
                alpha1 = np.arcsin(np.minimum(d1 * inv_sigma, 1.0))
                alpha3 = np.arcsin(np.minimum(d3 * inv_sigma, 1.0))
                h[i] = alpha3 - alpha1
            else:
                i = np.arange(i2, i3)
                t = t_offset + i * dt
                inv_sigma = 1.0 / np.sqrt(c2 * t**2 - z2)
                alpha2 = np.arcsin(np.minimum(d2 * inv_sigma, 1.0))
                alpha4 = np.arcsin(np.minimum(d4 * inv_sigma, 1.0))
                h[i] = alpha4 - alpha2
            i = np.arange(i3, i4)
            t = t_offset + i * dt
            inv_sigma = 1.0 / np.sqrt(c2 * t**2 - z2)
            alpha3 = np.arcsin(np.minimum(d3 * inv_sigma, 1.0))
            alpha4 = np.arcsin(np.minimum(d4 * inv_sigma, 1.0))
            h[i] = alpha3 + alpha4 - half_pi
        elif region == 2:
            i0 = 0
            i1 = math.ceil(ta  * self.sample_rate) - min_absolute_index
            i2 = math.ceil(tm1 * self.sample_rate) - min_absolute_index
            i3 = math.ceil(tm2 * self.sample_rate) - min_absolute_index
            i4 = max_absolute_index - min_absolute_index

            i = np.arange(i0, i1)
            t = t_offset + i * dt
            sigma = np.sqrt(np.maximum(c2 * t**2 - z2, 0.0))
            alpha2 = np.arcsin(np.minimum(d2 / sigma, 1.0))
            h[i] = np.pi - 2.0 * alpha2
            h[i[sigma <= sigma_eps]] = 0.0

            i = np.arange(i1, i2)
            t = t_offset + i * dt
            sigma = np.sqrt(np.maximum(c2 * t**2 - z2, 0.0))
            inv_sigma = 1.0 / sigma
            alpha1 = -np.arcsin(np.minimum(-d1 * inv_sigma, 1.0))
            alpha2 =  np.arcsin(np.minimum( d2 * inv_sigma, 1.0))
            h[i] = half_pi - alpha1 - alpha2
            h[i[sigma <= sigma_eps]] = 0.0

            i = np.arange(i2, i3)
            t = t_offset + i * dt
            inv_sigma = 1.0 / np.sqrt(c2 * t**2 - z2)
            alpha1 = -np.arcsin(np.minimum(-d1 * inv_sigma, 1.0))
            alpha3 =  np.arcsin(np.minimum( d3 * inv_sigma, 1.0))
            alpha4 =  np.arcsin(np.minimum( d4 * inv_sigma, 1.0))
            h[i] = alpha3 - alpha1 - np.pi + 2.0 * alpha4

            i = np.arange(i3, i4)
            t = t_offset + i * dt
            inv_sigma = 1.0 / np.sqrt(c2 * t**2 - z2)
            alpha3 = np.arcsin(np.minimum(d3 * inv_sigma, 1.0))
            alpha4 = np.arcsin(np.minimum(d4 * inv_sigma, 1.0))
            h[i] = alpha3 + alpha4 - half_pi
        elif region == 3:
            i0 = 0
            i1 = math.ceil(ta  * self.sample_rate) - min_absolute_index
            i2 = math.ceil(tm1 * self.sample_rate) - min_absolute_index
            i3 = math.ceil(tm2 * self.sample_rate) - min_absolute_index
            i4 = max_absolute_index - min_absolute_index

            i = np.arange(i0, i1)
            t = t_offset + i * dt
            sigma = np.sqrt(np.maximum(c2 * t**2 - z2, 0.0))
            inv_sigma = 1.0 / sigma
            alpha1 = np.arcsin(np.minimum(d1 * inv_sigma, 1.0))
            alpha3 = np.arcsin(np.minimum(d3 * inv_sigma, 1.0))
            h[i] = 2.0 * (alpha3 - alpha1)
            h[i[sigma <= sigma_eps]] = 0.0

            i = np.arange(i1, i2)
            t = t_offset + i * dt
            sigma = np.sqrt(np.maximum(c2 * t**2 - z2, 0.0))
            inv_sigma = 1.0 / sigma
            alpha1 =  np.arcsin(np.minimum( d1 * inv_sigma, 1.0))
            alpha2 = -np.arcsin(np.minimum(-d2 * inv_sigma, 1.0))
            alpha3 =  np.arcsin(np.minimum( d3 * inv_sigma, 1.0))
            h[i] = 2.0 * alpha3 - half_pi - alpha1 - alpha2
            h[i[sigma <= sigma_eps]] = 0.0
            if tb <= tc:
                i = np.arange(i2, i3)
                t = t_offset + i * dt
                inv_sigma = 1.0 / np.sqrt(c2 * t**2 - z2)
                alpha1 = np.arcsin(np.minimum(d1 * inv_sigma, 1.0))
                alpha3 = np.arcsin(np.minimum(d3 * inv_sigma, 1.0))
                h[i] = alpha3 - alpha1
            else:
                i = np.arange(i2, i3)
                t = t_offset + i * dt
                inv_sigma = 1.0 / np.sqrt(c2 * t**2 - z2)
                alpha2 = -np.arcsin(np.minimum(-d2 * inv_sigma, 1.0))
                alpha3 =  np.arcsin(np.minimum( d3 * inv_sigma, 1.0))
                alpha4 =  np.arcsin(np.minimum( d4 * inv_sigma, 1.0))
                h[i] = alpha4 - alpha2 - np.pi + 2.0 * alpha3
            i = np.arange(i3, i4)
            t = t_offset + i * dt
            inv_sigma = 1.0 / np.sqrt(c2 * t**2 - z2)
            alpha3 = np.arcsin(np.minimum(d3 * inv_sigma, 1.0))
            alpha4 = np.arcsin(np.minimum(d4 * inv_sigma, 1.0))
            h[i] = alpha3 + alpha4 - half_pi
        else: # region 4
            i0 = 0
            i1 = math.ceil(ta  * self.sample_rate) - min_absolute_index
            i2 = math.ceil(tm1 * self.sample_rate) - min_absolute_index
            i3 = math.ceil(tm2 * self.sample_rate) - min_absolute_index
            i4 = max_absolute_index - min_absolute_index

            i = np.arange(i0, i1)
            t = t_offset + i * dt
            sigma = np.sqrt(np.maximum(c2 * t**2 - z2, 0.0))
            inv_sigma = 1.0 / sigma
            alpha1 = -np.arcsin(np.minimum(-d1 * inv_sigma, 1.0))
            alpha2 = -np.arcsin(np.minimum(-d2 * inv_sigma, 1.0))
            alpha3 =  np.arcsin(np.minimum( d3 * inv_sigma, 1.0))
            alpha4 =  np.arcsin(np.minimum( d4 * inv_sigma, 1.0))
            h[i] = 2.0 * (alpha3 + alpha4 - alpha1 - alpha2 - np.pi)
            h[i[sigma <= sigma_eps]] = 0.0

            i = np.arange(i1, i2)
            t = t_offset + i * dt
            sigma = np.sqrt(np.maximum(c2 * t**2 - z2, 0.0))
            inv_sigma = 1.0 / sigma
            alpha1 = -np.arcsin(np.minimum(-d1 * inv_sigma, 1.0))
            alpha2 = -np.arcsin(np.minimum(-d2 * inv_sigma, 1.0))
            alpha3 =  np.arcsin(np.minimum( d3 * inv_sigma, 1.0))
            alpha4 =  np.arcsin(np.minimum( d4 * inv_sigma, 1.0))
            h[i] = 2.0 * (alpha3 + alpha4) - alpha1 - alpha2 - (3.0 * half_pi)
            h[i[sigma <= sigma_eps]] = 0.0
            if tb <= tc:
                i = np.arange(i2, i3)
                t = t_offset + i * dt
                inv_sigma = 1.0 / np.sqrt(c2 * t**2 - z2)
                alpha1 = -np.arcsin(np.minimum(-d1 * inv_sigma, 1.0))
                alpha3 =  np.arcsin(np.minimum( d3 * inv_sigma, 1.0))
                alpha4 =  np.arcsin(np.minimum( d4 * inv_sigma, 1.0))
                h[i] = alpha3 - alpha1 + 2.0 * alpha4 - np.pi
            else:
                i = np.arange(i2, i3)
                t = t_offset + i * dt
                inv_sigma = 1.0 / np.sqrt(c2 * t**2 - z2)
                alpha2 = -np.arcsin(np.minimum(-d2 * inv_sigma, 1.0))
                alpha3 =  np.arcsin(np.minimum( d3 * inv_sigma, 1.0))
                alpha4 =  np.arcsin(np.minimum( d4 * inv_sigma, 1.0))
                h[i] = alpha4 - alpha2 + 2.0 * alpha3 - np.pi
            i = np.arange(i3, i4)
            t = t_offset + i * dt
            inv_sigma = 1.0 / np.sqrt(c2 * t**2 - z2)
            alpha3 = np.arcsin(np.minimum(d3 * inv_sigma, 1.0))
            alpha4 = np.arcsin(np.minimum(d4 * inv_sigma, 1.0))
            h[i] = alpha3 + alpha4 - half_pi

        return min_absolute_index, (self.c / (2.0 * np.pi)) * h
