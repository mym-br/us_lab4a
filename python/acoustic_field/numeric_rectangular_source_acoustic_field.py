# This file is in the public domain.

import numpy as np
import matplotlib.pyplot as plt

# Calculate the acoustic field generated by a flat rectangular surface,
# using the numeric solution provided by:
#
# Piwakowski, B.
# Delannoy, B.
# Method for computing spatial pulse response: Time-domain approach
# J. Acoust. Soc. Am., vol. 86, no. 6, pp. 2422-2432, 1989.
# DOI: 10.1121/1.398449
#
# See also:
# Lasota, H.
# Salamon, R.
# Delannoy, B.
# Acoustic diffraction analysis by the impulse response method: A line impulse response approach},
# J. Acoust. Soc. Am., vol. 76, no. 1, pp. 280-290, 1984.
# DOI: 10.1121/1.391115
#
# Note:
# - The source is surrounded by a rigid baffle.
class NumericRectangularSourceAcousticField:
    def __init__(self, width, height, sample_rate, c, sub_elem_size):
        """Construct a NumericRectangularSourceAcousticField.

        width: Width of the source (m).
        height: Height of the source (m).
        sample_rate (Hz).
        c: Propagation speed (m/s).
        sub_elem_size: initial width/height for each sub-element (m).
        """
        self.a = width / 2
        self.b = height / 2
        self.sample_rate = sample_rate
        self.inv_c = 1.0 / c

        if sub_elem_size > width:
            self.num_elem_x = 1
        else:
            self.num_elem_x = int(np.ceil(width / sub_elem_size))
        if sub_elem_size > height:
            self.num_elem_y = 1
        else:
            self.num_elem_y = int(np.ceil(height / sub_elem_size))
        self.sub_elem_w = width / self.num_elem_x
        self.sub_elem_h = height / self.num_elem_y

        end_x = 0.5 * (self.num_elem_x - 1)
        sub_elem_x_list = np.linspace(-end_x, end_x, self.num_elem_x) * self.sub_elem_w
        end_y = 0.5 * (self.num_elem_y - 1)
        sub_elem_y_list = np.linspace(-end_y, end_y, self.num_elem_y) * self.sub_elem_h

        self.sub_elem_y, self.sub_elem_x = np.meshgrid(sub_elem_y_list, sub_elem_x_list, indexing='ij')

        print("num_elem_x={} num_elem_y={} total={}".format(self.num_elem_x, self.num_elem_y, self.num_elem_x * self.num_elem_y))

    def plot_sub_elements(self):
        plt.figure()
        plt.plot(self.sub_elem_x.flat, self.sub_elem_y.flat, '.')
        plt.plot([ self.a, self.a, -self.a, -self.a,  self.a],
                 [-self.b, self.b,  self.b, -self.b, -self.b])
        plt.grid(True)
        plt.title("Sub-elements")
        plt.xlabel("x (m)")
        plt.ylabel("y (m)")
        plt.axis("Equal")

    def get_impulse_response(self, x, y, z):
        """Get the impulse velocity potential at a point.

        x, y, z: Coordinates of the point (m).

        Return:
            offset: Absolute index of the first sample in h.
            h:      Impulse velocity potential.
        """

        r = np.sqrt((x - self.sub_elem_x)**2 + (y - self.sub_elem_y)**2 + z**2)
        n0 = r * (self.inv_c * self.sample_rate)
        n = np.rint(n0).astype(np.int32)

        min_n = np.min(n)
        max_n = np.max(n)
        n -= min_n
        h = np.zeros(max_n - min_n + np.int32(1))
        value = (self.sample_rate * self.sub_elem_w * self.sub_elem_h * 0.5 / np.pi) / r
        for n_item, value_item in zip(n.flat, value.flat):
            h[n_item] += value_item

        return min_n, h
