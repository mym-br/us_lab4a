/***************************************************************************
 *  Copyright 2018 Marcelo Y. Matuda                                       *
 *                                                                         *
 *  This program is free software: you can redistribute it and/or modify   *
 *  it under the terms of the GNU General Public License as published by   *
 *  the Free Software Foundation, either version 3 of the License, or      *
 *  (at your option) any later version.                                    *
 *                                                                         *
 *  This program is distributed in the hope that it will be useful,        *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of         *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
 *  GNU General Public License for more details.                           *
 *                                                                         *
 *  You should have received a copy of the GNU General Public License      *
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
 ***************************************************************************/
#ifndef ANALYTICRECTANGULARSOURCEIMPULSERESPONSE_H
#define ANALYTICRECTANGULARSOURCEIMPULSERESPONSE_H

#include <algorithm> /* max, min */
#include <cmath>
#include <cstddef> /* std::size_t */
#include <limits>
#include <vector>
#include <utility> /* swap */

#include "Exception.h"
#include "Util.h"



namespace Lab {

// Calculate the acoustic field generated by a rectangular surface,
// using the analytic solution provided by:
// Emeterio, J. L. S.
// Ullate, L. G.
// Diffraction impulse response of rectangular transducers.
// J. Acoust. Soc. Am., vol. 92, no. 2, pp. 651-662, 1992.
// DOI: 10.1121/1.403990
//
// Note:
// - The source is surrounded by a rigid baffle.
template<typename TFloat>
class AnalyticRectangularSourceImpulseResponse {
public:
	AnalyticRectangularSourceImpulseResponse(
					TFloat samplingFreq,
					TFloat propagationSpeed,
					TFloat sourceWidth,
					TFloat sourceHeight,
					TFloat minEdgeDivisor);

	// Return h/c.
	void getImpulseResponse(TFloat x, TFloat y, TFloat z,
				std::size_t& hOffset /* samples */, std::vector<TFloat>& h);
private:
	static TFloat alphaP(TFloat v);
	static TFloat alphaN(TFloat v);

	TFloat samplingFreq_;
	TFloat propagationSpeed_;
	TFloat a_;
	TFloat b_;
	TFloat minADivisor_;
	bool swapXY_;
};



template<typename TFloat>
AnalyticRectangularSourceImpulseResponse<TFloat>::AnalyticRectangularSourceImpulseResponse(
		TFloat samplingFreq,
		TFloat propagationSpeed,
		TFloat sourceWidth,
		TFloat sourceHeight,
		TFloat minEdgeDivisor)
			: samplingFreq_(samplingFreq)
			, propagationSpeed_(propagationSpeed)
			, a_(sourceWidth / 2)
			, b_(sourceHeight / 2)
			, minADivisor_(minEdgeDivisor / 2)
			, swapXY_()
{
	if (a_ > b_) {
		std::swap(a_, b_);
		swapXY_ = true;
	}
}

template<typename TFloat>
TFloat
AnalyticRectangularSourceImpulseResponse<TFloat>::alphaP(TFloat v)
{
	return std::asin(std::min(v, TFloat(1)));
}

template<typename TFloat>
TFloat
AnalyticRectangularSourceImpulseResponse<TFloat>::alphaN(TFloat v)
{
	return -std::asin(std::min(-v, TFloat(1)));
}

template<typename TFloat>
void
AnalyticRectangularSourceImpulseResponse<TFloat>::getImpulseResponse(
								TFloat x,
								TFloat y,
								TFloat z,
								std::size_t& hOffset,
								std::vector<TFloat>& h)
{
	// The field is symmetric.
	x = std::abs(x);
	y = std::abs(y);
	z = std::abs(z);

	if (swapXY_) std::swap(x, y);

	const TFloat z2 = z * z;
	const TFloat c2 = propagationSpeed_ * propagationSpeed_;
	constexpr TFloat halfPi = pi / 2.0;
	constexpr TFloat halfPi3 = 3.0 * pi / 2.0;

	// Figure 2.
	const TFloat d1 = x - a_;
	const TFloat d2 = y - b_;
	const TFloat d3 = x + a_; // d3 > 0
	const TFloat d4 = y + b_; // d4 > 0

	const TFloat d1_2 = d1 * d1;
	const TFloat d2_2 = d2 * d2;
	const TFloat d3_2 = d3 * d3;
	const TFloat d4_2 = d4 * d4;

	const TFloat invC = 1 / propagationSpeed_;

	// (7)
	const TFloat ta = std::sqrt(d1_2 + d2_2 + z2) * invC;
	const TFloat tb = std::sqrt(d2_2 + d3_2 + z2) * invC;
	const TFloat tc = std::sqrt(d1_2 + d4_2 + z2) * invC;
	const TFloat td = std::sqrt(d3_2 + d4_2 + z2) * invC;
	// (8)
	const TFloat ts1 = std::sqrt(d1_2 + z2) * invC;
	const TFloat ts2 = std::sqrt(d2_2 + z2) * invC;
	// (9)
	const TFloat t0 = z * invC;

	// Determine the region and the start time of the impulse response.
	unsigned int region;
	TFloat tMin;
	if (x >= a_) {
		if (y >= b_) {
			region = 1;
			tMin = ta;
		} else {
			region = 3;
			tMin = ts1;
		}
	} else {
		if (y >= b_) {
			region = 2;
			tMin = ts2;
		} else {
			region = 4;
			tMin = t0;
		}
	}

	const TFloat dt = 1 / samplingFreq_;
	if (minADivisor_ > 0.0) {
		const TFloat deltaA = a_ / minADivisor_;
		const TFloat sigma1 = std::sqrt(std::max(c2 * tMin * tMin - z2, TFloat(0)));
		const TFloat sigma2 = sigma1 + deltaA;
		const TFloat maxDt = std::sqrt(sigma2 * sigma2 + z2) * invC - tMin;
		if (dt > maxDt) {
			THROW_EXCEPTION(InvalidValueException,
				"The sampling rate is too low (fs=" << samplingFreq_ << " min_fs=" << 1.0 / maxDt << ").");
		}
	}

	// (13)
	const TFloat tm1 = std::min(tb, tc);
	const TFloat tm2 = std::max(tb, tc);

	const std::size_t minAbsoluteIndex = static_cast<std::size_t>(std::ceil(tMin * samplingFreq_));
	const std::size_t maxAbsoluteIndex = static_cast<std::size_t>(std::ceil(td * samplingFreq_));
	h.assign(maxAbsoluteIndex - minAbsoluteIndex + 1, 0);
	const TFloat tOffset = minAbsoluteIndex * dt;

	const TFloat sigmaEps = a_ * std::numeric_limits<TFloat>::epsilon();

	switch (region) {
	case 1:
	{
		const std::size_t i1 = 0;
		const std::size_t i2 = static_cast<std::size_t>(std::ceil(tm1 * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i3 = static_cast<std::size_t>(std::ceil(tm2 * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i4 = maxAbsoluteIndex - minAbsoluteIndex;

		for (std::size_t i = i1; i < i2; ++i) {
			const TFloat t = tOffset + i * dt;
			const TFloat sigma = std::sqrt(std::max(c2 * t * t - z2, TFloat(0)));
			if (sigma <= sigmaEps) continue;
			const TFloat invSigma = 1 / sigma;
			const TFloat alpha1 = alphaP(d1 * invSigma);
			const TFloat alpha2 = alphaP(d2 * invSigma);
			h[i] = halfPi - alpha1 - alpha2;
		}
		if (tb <= tc) {
			for (std::size_t i = i2; i < i3; ++i) {
				const TFloat t = tOffset + i * dt;
				const TFloat invSigma = 1 / std::sqrt(c2 * t * t - z2);
				const TFloat alpha1 = alphaP(d1 * invSigma);
				const TFloat alpha3 = alphaP(d3 * invSigma);
				h[i] = alpha3 - alpha1;
			}
		} else {
			for (std::size_t i = i2; i < i3; ++i) {
				const TFloat t = tOffset + i * dt;
				const TFloat invSigma = 1 / std::sqrt(c2 * t * t - z2);
				const TFloat alpha2 = alphaP(d2 * invSigma);
				const TFloat alpha4 = alphaP(d4 * invSigma);
				h[i] = alpha4 - alpha2;
			}
		}
		for (std::size_t i = i3; i < i4; ++i) {
			const TFloat t = tOffset + i * dt;
			const TFloat invSigma = 1 / std::sqrt(c2 * t * t - z2);
			const TFloat alpha3 = alphaP(d3 * invSigma);
			const TFloat alpha4 = alphaP(d4 * invSigma);
			h[i] = alpha3 + alpha4 - halfPi;
		}
		break;
	}
	case 2:
	{
		const std::size_t i0 = 0;
		const std::size_t i1 = static_cast<std::size_t>(std::ceil(ta  * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i2 = static_cast<std::size_t>(std::ceil(tm1 * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i3 = static_cast<std::size_t>(std::ceil(tm2 * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i4 = maxAbsoluteIndex - minAbsoluteIndex;

		for (std::size_t i = i0; i < i1; ++i) {
			const TFloat t = tOffset + i * dt;
			const TFloat sigma = std::sqrt(std::max(c2 * t * t - z2, TFloat(0)));
			if (sigma <= sigmaEps) continue;
			const TFloat alpha2 = alphaP(d2 / sigma);
			h[i] = TFloat(pi) - 2 * alpha2;
		}
		for (std::size_t i = i1; i < i2; ++i) {
			const TFloat t = tOffset + i * dt;
			const TFloat sigma = std::sqrt(std::max(c2 * t * t - z2, TFloat(0)));
			if (sigma <= sigmaEps) continue;
			const TFloat invSigma = 1 / sigma;
			const TFloat alpha1 = alphaN(d1 * invSigma);
			const TFloat alpha2 = alphaP(d2 * invSigma);
			h[i] = halfPi - alpha1 - alpha2;
		}
		for (std::size_t i = i2; i < i3; ++i) {
			const TFloat t = tOffset + i * dt;
			const TFloat invSigma = 1 / std::sqrt(c2 * t * t - z2);
			const TFloat alpha1 = alphaN(d1 * invSigma);
			const TFloat alpha3 = alphaP(d3 * invSigma);
			const TFloat alpha4 = alphaP(d4 * invSigma);
			h[i] = alpha3 - alpha1 - TFloat(pi) + 2 * alpha4;
		}
		for (std::size_t i = i3; i < i4; ++i) {
			const TFloat t = tOffset + i * dt;
			const TFloat invSigma = 1 / std::sqrt(c2 * t * t - z2);
			const TFloat alpha3 = alphaP(d3 * invSigma);
			const TFloat alpha4 = alphaP(d4 * invSigma);
			h[i] = alpha3 + alpha4 - halfPi;
		}
		break;
	}
	case 3:
	{
		const std::size_t i0 = 0;
		const std::size_t i1 = static_cast<std::size_t>(std::ceil(ta  * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i2 = static_cast<std::size_t>(std::ceil(tm1 * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i3 = static_cast<std::size_t>(std::ceil(tm2 * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i4 = maxAbsoluteIndex - minAbsoluteIndex;

		for (std::size_t i = i0; i < i1; ++i) {
			const TFloat t = tOffset + i * dt;
			const TFloat sigma = std::sqrt(std::max(c2 * t * t - z2, TFloat(0)));
			if (sigma <= sigmaEps) continue;
			const TFloat invSigma = 1 / sigma;
			const TFloat alpha1 = alphaP(d1 * invSigma);
			const TFloat alpha3 = alphaP(d3 * invSigma);
			h[i] = 2 * (alpha3 - alpha1);
		}
		for (std::size_t i = i1; i < i2; ++i) {
			const TFloat t = tOffset + i * dt;
			const TFloat sigma = std::sqrt(std::max(c2 * t * t - z2, TFloat(0)));
			if (sigma <= sigmaEps) continue;
			const TFloat invSigma = 1 / sigma;
			const TFloat alpha1 = alphaP(d1 * invSigma);
			const TFloat alpha2 = alphaN(d2 * invSigma);
			const TFloat alpha3 = alphaP(d3 * invSigma);
			h[i] = 2 * alpha3 - halfPi - alpha1 - alpha2;
		}
		if (tb <= tc ) {
			for (std::size_t i = i2; i < i3; ++i) {
				const TFloat t = tOffset + i * dt;
				const TFloat invSigma = 1 / std::sqrt(c2 * t * t - z2);
				const TFloat alpha1 = alphaP(d1 * invSigma);
				const TFloat alpha3 = alphaP(d3 * invSigma);
				h[i] = alpha3 - alpha1;
			}
		} else {
			for (std::size_t i = i2; i < i3; ++i) {
				const TFloat t = tOffset + i * dt;
				const TFloat invSigma = 1 / std::sqrt(c2 * t * t - z2);
				const TFloat alpha2 = alphaN(d2 * invSigma);
				const TFloat alpha3 = alphaP(d3 * invSigma);
				const TFloat alpha4 = alphaP(d4 * invSigma);
				h[i] = alpha4 - alpha2 - TFloat(pi) + 2 * alpha3;
			}
		}
		for (std::size_t i = i3; i < i4; ++i) {
			const TFloat t = tOffset + i * dt;
			const TFloat invSigma = 1 / std::sqrt(c2 * t * t - z2);
			const TFloat alpha3 = alphaP(d3 * invSigma);
			const TFloat alpha4 = alphaP(d4 * invSigma);
			h[i] = alpha3 + alpha4 - halfPi;
		}
		break;
	}
	case 4:
	{
		const std::size_t i0 = 0;
		const std::size_t i1 = static_cast<std::size_t>(std::ceil(ta  * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i2 = static_cast<std::size_t>(std::ceil(tm1 * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i3 = static_cast<std::size_t>(std::ceil(tm2 * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i4 = maxAbsoluteIndex - minAbsoluteIndex;

		for (std::size_t i = i0; i < i1; ++i) {
			const TFloat t = tOffset + i * dt;
			const TFloat sigma = std::sqrt(std::max(c2 * t * t - z2, TFloat(0)));
			if (sigma <= sigmaEps) continue;
			const TFloat invSigma = 1 / sigma;
			const TFloat alpha1 = alphaN(d1 * invSigma);
			const TFloat alpha2 = alphaN(d2 * invSigma);
			const TFloat alpha3 = alphaP(d3 * invSigma);
			const TFloat alpha4 = alphaP(d4 * invSigma);
			h[i] = 2 * (alpha3 + alpha4 - alpha1 - alpha2 - TFloat(pi));
		}
		for (std::size_t i = i1; i < i2; ++i) {
			const TFloat t = tOffset + i * dt;
			const TFloat sigma = std::sqrt(std::max(c2 * t * t - z2, TFloat(0)));
			if (sigma <= sigmaEps) continue;
			const TFloat invSigma = 1 / sigma;
			const TFloat alpha1 = alphaN(d1 * invSigma);
			const TFloat alpha2 = alphaN(d2 * invSigma);
			const TFloat alpha3 = alphaP(d3 * invSigma);
			const TFloat alpha4 = alphaP(d4 * invSigma);
			h[i] = 2 * (alpha3 + alpha4) - alpha1 - alpha2 - halfPi3;
		}
		if (tb <= tc) {
			for (std::size_t i = i2; i < i3; ++i) {
				const TFloat t = tOffset + i * dt;
				const TFloat invSigma = 1 / std::sqrt(c2 * t * t - z2);
				const TFloat alpha1 = alphaN(d1 * invSigma);
				const TFloat alpha3 = alphaP(d3 * invSigma);
				const TFloat alpha4 = alphaP(d4 * invSigma);
				h[i] = alpha3 - alpha1 + 2 * alpha4 - TFloat(pi);
			}
		} else {
			for (std::size_t i = i2; i < i3; ++i) {
				const TFloat t = tOffset + i * dt;
				const TFloat invSigma = 1 / std::sqrt(c2 * t * t - z2);
				const TFloat alpha2 = alphaN(d2 * invSigma);
				const TFloat alpha3 = alphaP(d3 * invSigma);
				const TFloat alpha4 = alphaP(d4 * invSigma);
				h[i] = alpha4 - alpha2 + 2 * alpha3 - TFloat(pi);
			}
		}
		for (std::size_t i = i3; i < i4; ++i) {
			const TFloat t = tOffset + i * dt;
			const TFloat invSigma = 1 / std::sqrt(c2 * t * t - z2);
			const TFloat alpha3 = alphaP(d3 * invSigma);
			const TFloat alpha4 = alphaP(d4 * invSigma);
			h[i] = alpha3 + alpha4 - halfPi;
		}
		break;
	}
	}

	//Util::multiply(h, propagationSpeed_ / TFloat(2.0 * pi));
	Util::multiply(h, 1 / TFloat(2.0 * pi));
	hOffset = minAbsoluteIndex;
}

} // namespace Lab

#endif // ANALYTICRECTANGULARSOURCEIMPULSERESPONSE_H
