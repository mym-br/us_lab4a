/***************************************************************************
 *  Copyright 2019 Marcelo Y. Matuda                                       *
 *                                                                         *
 *  This program is free software: you can redistribute it and/or modify   *
 *  it under the terms of the GNU General Public License as published by   *
 *  the Free Software Foundation, either version 3 of the License, or      *
 *  (at your option) any later version.                                    *
 *                                                                         *
 *  This program is distributed in the hope that it will be useful,        *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of         *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
 *  GNU General Public License for more details.                           *
 *                                                                         *
 *  You should have received a copy of the GNU General Public License      *
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
 ***************************************************************************/
#ifndef ANALYTICCIRCULARSOURCEIMPULSERESPONSE_H
#define ANALYTICCIRCULARSOURCEIMPULSERESPONSE_H

#include <algorithm> /* max, min */
#include <cmath>
#include <cstddef> /* std::size_t */
#include <limits>

#include "Util.h"



namespace Lab {

// Calculate the acoustic field generated by a circular surface,
// using the analytic solution provided by:
// Robinson, D. E.
// Lees, S.
// Bess, L.
// Near field transient radiation patterns for circular pistons.
// IEEE Transactions on Acoustics, Speech, and Signal Processing
// DOI: 10.1109/TASSP.1974.1162612
//
// Note:
// - The source is surrounded by a rigid baffle.
template<typename TFloat>
class AnalyticCircularSourceImpulseResponse {
public:
	AnalyticCircularSourceImpulseResponse(
					TFloat samplingFreq,
					TFloat propagationSpeed,
					TFloat sourceRadius,
					TFloat discretization=0.0 /* not used */);

	// Return h/c.
	void getImpulseResponse(TFloat x, TFloat y, TFloat z,
				std::size_t& hOffset /* samples */, std::vector<TFloat>& h);
private:
	TFloat samplingFreq_;
	TFloat propagationSpeed_;
	TFloat r_;
};



template<typename TFloat>
AnalyticCircularSourceImpulseResponse<TFloat>::AnalyticCircularSourceImpulseResponse(
		TFloat samplingFreq,
		TFloat propagationSpeed,
		TFloat sourceRadius,
		TFloat /*discretization*/)
			: samplingFreq_(samplingFreq)
			, propagationSpeed_(propagationSpeed)
			, r_(sourceRadius)
{
}

template<typename TFloat>
void
AnalyticCircularSourceImpulseResponse<TFloat>::getImpulseResponse(
								TFloat x,
								TFloat y,
								TFloat z,
								std::size_t& hOffset,
								std::vector<TFloat>& h)
{
	// The field is symmetric.
	x = std::sqrt(x * x + y * y);
	z = std::abs(z);

	const TFloat x2 = x * x;
	const TFloat z2 = z * z;
	const TFloat c2 = propagationSpeed_ * propagationSpeed_;
	const TFloat r2 = r_ * r_;
	const TFloat d1 = x - r_;
	const TFloat d2 = x + r_;
	const TFloat invC = 1 / propagationSpeed_;
	const TFloat t0 = z * invC;
	const TFloat t1 = std::sqrt(d1 * d1 + z2) * invC;
	const TFloat t2 = std::sqrt(d2 * d2 + z2) * invC;

	// Determine the region and the start time of the impulse response.
	unsigned int region;
	TFloat tMin;
	if (x < r_) {
		region = 1;
		tMin = t0;
	} else {
		region = 2;
		tMin = t1;
	}

	const TFloat dt = 1 / samplingFreq_;

	const std::size_t minAbsoluteIndex = static_cast<std::size_t>(std::ceil(tMin * samplingFreq_));
	const std::size_t maxAbsoluteIndex = static_cast<std::size_t>(std::ceil(t2 * samplingFreq_));
	h.assign(maxAbsoluteIndex - minAbsoluteIndex + 1, 0);
	const TFloat tOffset = minAbsoluteIndex * dt;

	const TFloat sigmaEps = r_ * std::numeric_limits<TFloat>::epsilon();

	auto setTheta = [&](TFloat t, TFloat& theta) {
		const TFloat k1 = c2 * t * t - z2;
		const TFloat sigma = (2 * x) * std::sqrt(std::max(k1, TFloat(0)));
		if (sigma <= sigmaEps) return;
		const TFloat k2 = (k1 + x2 - r2) / sigma;
		if (k2 >= 0) {
			theta = std::acos(std::min(k2, TFloat(1)));
		} else {
			theta = std::acos(std::max(k2, TFloat(-1)));
		}
	};

	switch (region) {
	case 1:
	{
		const std::size_t i0 = 0;
		const std::size_t i1 = static_cast<std::size_t>(std::ceil(t1 * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i2 = maxAbsoluteIndex - minAbsoluteIndex;

		for (std::size_t i = i0; i < i1; ++i) {
			h[i] = pi;
		}
		for (std::size_t i = i1; i < i2; ++i) {
			setTheta(tOffset + i * dt, h[i]);
		}
		break;
	}
	case 2:
	{
		const std::size_t i1 = 0;
		const std::size_t i2 = maxAbsoluteIndex - minAbsoluteIndex;

		for (std::size_t i = i1; i < i2; ++i) {
			setTheta(tOffset + i * dt, h[i]);
		}
		break;
	}
	}

	//Util::multiply(h, propagationSpeed_ / TFloat(pi));
	Util::multiply(h, 1 / TFloat(pi));
	hOffset = minAbsoluteIndex;
}

} // namespace Lab

#endif // ANALYTICCIRCULARSOURCEIMPULSERESPONSE_H
