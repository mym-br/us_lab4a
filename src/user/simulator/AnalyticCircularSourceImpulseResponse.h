/***************************************************************************
 *  Copyright 2019 Marcelo Y. Matuda                                       *
 *                                                                         *
 *  This program is free software: you can redistribute it and/or modify   *
 *  it under the terms of the GNU General Public License as published by   *
 *  the Free Software Foundation, either version 3 of the License, or      *
 *  (at your option) any later version.                                    *
 *                                                                         *
 *  This program is distributed in the hope that it will be useful,        *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of         *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
 *  GNU General Public License for more details.                           *
 *                                                                         *
 *  You should have received a copy of the GNU General Public License      *
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
 ***************************************************************************/
#ifndef ANALYTICCIRCULARSOURCEIMPULSERESPONSE_H
#define ANALYTICCIRCULARSOURCEIMPULSERESPONSE_H

#include <algorithm> /* max, min */
#include <cmath>
#include <cstddef> /* std::size_t */
#include <limits>

#include "Util.h"



namespace Lab {

// Calculates the acoustic field generated by a circular surface,
// using the analytic solution provided by:
// Robinson, D. E.
// Lees, S.
// Bess, L.
// Near field transient radiation patterns for circular pistons.
// IEEE Transactions on Acoustics, Speech, and Signal Processing
// DOI: 10.1109/TASSP.1974.1162612
//
// Note:
// - The source is surrounded by a rigid baffle.
template<typename FloatType>
class AnalyticCircularSourceImpulseResponse {
public:
	AnalyticCircularSourceImpulseResponse(
					FloatType samplingFreq,
					FloatType propagationSpeed,
					FloatType sourceRadius,
					FloatType discretization=0.0 /* not used */);
	~AnalyticCircularSourceImpulseResponse() {}

	// Return h/c.
	void getImpulseResponse(FloatType x, FloatType y, FloatType z,
				std::size_t& hOffset /* samples */, std::vector<FloatType>& h);
private:
	FloatType samplingFreq_;
	FloatType propagationSpeed_;
	FloatType r_;
};



template<typename FloatType>
AnalyticCircularSourceImpulseResponse<FloatType>::AnalyticCircularSourceImpulseResponse(
		FloatType samplingFreq,
		FloatType propagationSpeed,
		FloatType sourceRadius,
		FloatType /*discretization*/)
			: samplingFreq_(samplingFreq)
			, propagationSpeed_(propagationSpeed)
			, r_(sourceRadius)
{
}

template<typename FloatType>
void
AnalyticCircularSourceImpulseResponse<FloatType>::getImpulseResponse(
								FloatType x,
								FloatType y,
								FloatType z,
								std::size_t& hOffset,
								std::vector<FloatType>& h)
{
	// The field is symmetric.
	x = std::sqrt(x * x + y * y);
	z = std::abs(z);

	const FloatType x2 = x * x;
	const FloatType z2 = z * z;
	const FloatType c2 = propagationSpeed_ * propagationSpeed_;
	const FloatType r2 = r_ * r_;
	const FloatType d1 = x - r_;
	const FloatType d2 = x + r_;
	const FloatType invC = 1 / propagationSpeed_;
	const FloatType t0 = z * invC;
	const FloatType t1 = std::sqrt(d1 * d1 + z2) * invC;
	const FloatType t2 = std::sqrt(d2 * d2 + z2) * invC;

	// Determine the region and the start time of the impulse response.
	unsigned int region;
	FloatType tMin;
	if (x < r_) {
		region = 1;
		tMin = t0;
	} else {
		region = 2;
		tMin = t1;
	}

	const FloatType dt = 1 / samplingFreq_;

	const std::size_t minAbsoluteIndex = static_cast<std::size_t>(std::ceil(tMin * samplingFreq_));
	const std::size_t maxAbsoluteIndex = static_cast<std::size_t>(std::ceil(t2 * samplingFreq_));
	h.assign(maxAbsoluteIndex - minAbsoluteIndex + 1, 0);
	const FloatType tOffset = minAbsoluteIndex * dt;

	const FloatType sigmaEps = r_ * std::numeric_limits<FloatType>::epsilon();

	auto setTheta = [&](FloatType t, FloatType& theta) {
		const FloatType k1 = c2 * t * t - z2;
		const FloatType sigma = (2 * x) * std::sqrt(std::max(k1, FloatType(0)));
		if (sigma <= sigmaEps) return;
		const FloatType k2 = (k1 + x2 - r2) / sigma;
		if (k2 >= 0) {
			theta = std::acos(std::min(k2, FloatType(1)));
		} else {
			theta = std::acos(std::max(k2, FloatType(-1)));
		}
	};

	switch (region) {
	case 1:
	{
		const std::size_t i0 = 0;
		const std::size_t i1 = static_cast<std::size_t>(std::ceil(t1 * samplingFreq_)) - minAbsoluteIndex;
		const std::size_t i2 = maxAbsoluteIndex - minAbsoluteIndex;

		for (std::size_t i = i0; i < i1; ++i) {
			h[i] = pi;
		}
		for (std::size_t i = i1; i < i2; ++i) {
			setTheta(tOffset + i * dt, h[i]);
		}
		break;
	}
	case 2:
	{
		const std::size_t i1 = 0;
		const std::size_t i2 = maxAbsoluteIndex - minAbsoluteIndex;

		for (std::size_t i = i1; i < i2; ++i) {
			setTheta(tOffset + i * dt, h[i]);
		}
		break;
	}
	}

	//Util::multiply(h, propagationSpeed_ / FloatType(pi));
	Util::multiply(h, 1 / FloatType(pi));
	hOffset = minAbsoluteIndex;
}

} // namespace Lab

#endif // ANALYTICCIRCULARSOURCEIMPULSERESPONSE_H
